import { AbiFunction, ContractParam, ContractSource, FullPublishMetadata, PreDeployMetadataFetched, ProfileMetadata, PublishedContract, PublishedContractFetched, SDKOptions } from "../../schema";
import { NetworkInput } from "../types";
import { RPCConnectionHandler } from "./rpc-connection-handler";
import { Transaction } from "./transactions";
import { ThirdwebStorage } from "@thirdweb-dev/storage";
/**
 * Handles publishing contracts (EXPERIMENTAL)
 * @internal
 */
export declare class ContractPublisher extends RPCConnectionHandler {
    private storage;
    private publisher;
    constructor(network: NetworkInput, options: SDKOptions, storage: ThirdwebStorage);
    updateSignerOrProvider(network: NetworkInput): void;
    /**
     * @internal
     * @param metadataUri
     */
    extractConstructorParams(metadataUri: string): Promise<ContractParam[]>;
    /**
     * @internal
     * @param predeployMetadataUri
     */
    extractFunctions(predeployMetadataUri: string): Promise<AbiFunction[]>;
    /**
     * @internal
     * @param predeployUri
     */
    fetchCompilerMetadataFromPredeployURI(predeployUri: string): Promise<PreDeployMetadataFetched>;
    /**
     * @internal
     * @param prepublishUri
     * @param publisherAddress
     */
    fetchPrePublishMetadata(prepublishUri: string, publisherAddress: string): Promise<{
        preDeployMetadata: PreDeployMetadataFetched;
        latestPublishedContractMetadata?: PublishedContractFetched;
    }>;
    /**
     * @internal
     * @param address
     */
    fetchCompilerMetadataFromAddress(address: string): Promise<{
        name: string;
        metadata: Record<string, any>;
        abi: {
            [x: string]: any;
            type: string;
            name: string;
            inputs: {
                [x: string]: any;
                stateMutability?: string | undefined;
                components?: {
                    [x: string]: any;
                    type: string;
                    name: string;
                }[] | undefined;
                type: string;
                name: string;
            }[];
            outputs: {
                [x: string]: any;
                stateMutability?: string | undefined;
                components?: {
                    [x: string]: any;
                    type: string;
                    name: string;
                }[] | undefined;
                type: string;
                name: string;
            }[];
        }[];
        info: {
            title?: string | undefined;
            author?: string | undefined;
            details?: string | undefined;
            notice?: string | undefined;
        };
        licenses: string[];
    }>;
    /**
     * @internal
     * Get the full information about a published contract
     * @param contract
     */
    fetchPublishedContractInfo(contract: PublishedContract): Promise<PublishedContractFetched>;
    /**
     * @internal
     * @param publishedMetadataUri
     */
    fetchFullPublishMetadata(publishedMetadataUri: string): Promise<FullPublishMetadata>;
    /**
     * @internal
     * // TODO expose a resolvePublishMetadata(contractAddress, chainId) that handles the dual chain case
     * // TODO will be easy to do with the multichain pattern of 3.0
     * @param compilerMetadataUri
     */
    resolvePublishMetadataFromCompilerMetadata(compilerMetadataUri: string): Promise<FullPublishMetadata[]>;
    /**
     * @internal
     * TODO clean this up (see method above, too)
     */
    resolveContractUriFromAddress(address: string): Promise<string>;
    /**
     * @internal
     * @param address
     */
    fetchContractSourcesFromAddress(address: string): Promise<ContractSource[]>;
    /**
     * @internal
     * @param profileMetadata
     */
    updatePublisherProfile: {
        (profileMetadata: {
            name?: string | undefined;
            bio?: string | undefined;
            avatar?: any;
            website?: string | undefined;
            twitter?: string | undefined;
            telegram?: string | undefined;
            facebook?: string | undefined;
            github?: string | undefined;
            medium?: string | undefined;
            linkedin?: string | undefined;
            reddit?: string | undefined;
            discord?: string | undefined;
        }): Promise<Omit<{
            receipt: import("@ethersproject/abstract-provider").TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>;
        prepare: (profileMetadata: {
            name?: string | undefined;
            bio?: string | undefined;
            avatar?: any;
            website?: string | undefined;
            twitter?: string | undefined;
            telegram?: string | undefined;
            facebook?: string | undefined;
            github?: string | undefined;
            medium?: string | undefined;
            linkedin?: string | undefined;
            reddit?: string | undefined;
            discord?: string | undefined;
        }) => Promise<Transaction<Omit<{
            receipt: import("@ethersproject/abstract-provider").TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>>;
    };
    /**
     * @internal
     * @param publisherAddress
     */
    getPublisherProfile(publisherAddress: string): Promise<ProfileMetadata>;
    /**
     * @internal
     * @param publisherAddress
     */
    getAll(publisherAddress: string): Promise<PublishedContract[]>;
    /**
     * @internal
     * @param publisherAddress
     * @param contractId
     */
    getAllVersions(publisherAddress: string, contractId: string): Promise<PublishedContract[]>;
    getVersion(publisherAddress: string, contractId: string, version?: string): Promise<PublishedContract | undefined>;
    getLatest(publisherAddress: string, contractId: string): Promise<PublishedContract | undefined>;
    publish: {
        (predeployUri: string, extraMetadata: {
            [x: string]: any;
            description?: string | undefined;
            displayName?: string | undefined;
            readme?: string | undefined;
            license?: string | undefined;
            changelog?: string | undefined;
            tags?: string[] | undefined;
            audit?: any;
            logo?: any;
            isDeployableViaFactory?: boolean | undefined;
            isDeployableViaProxy?: boolean | undefined;
            factoryDeploymentData?: {
                implementationInitializerFunction?: string | undefined;
                factoryAddresses?: Record<string, string> | undefined;
                implementationAddresses: Record<string, string>;
            } | undefined;
            constructorParams?: Record<string, {
                [x: string]: any;
                description?: string | undefined;
                displayName?: string | undefined;
                defaultValue?: string | undefined;
            }> | undefined;
            version: string;
        }): Promise<{
            receipt: import("@ethersproject/abstract-provider").TransactionReceipt;
            data: () => Promise<{
                id: string;
                metadataUri: string;
                timestamp: string;
            }>;
        }>;
        prepare: (predeployUri: string, extraMetadata: {
            [x: string]: any;
            description?: string | undefined;
            displayName?: string | undefined;
            readme?: string | undefined;
            license?: string | undefined;
            changelog?: string | undefined;
            tags?: string[] | undefined;
            audit?: any;
            logo?: any;
            isDeployableViaFactory?: boolean | undefined;
            isDeployableViaProxy?: boolean | undefined;
            factoryDeploymentData?: {
                implementationInitializerFunction?: string | undefined;
                factoryAddresses?: Record<string, string> | undefined;
                implementationAddresses: Record<string, string>;
            } | undefined;
            constructorParams?: Record<string, {
                [x: string]: any;
                description?: string | undefined;
                displayName?: string | undefined;
                defaultValue?: string | undefined;
            }> | undefined;
            version: string;
        }) => Promise<Transaction<{
            receipt: import("@ethersproject/abstract-provider").TransactionReceipt;
            data: () => Promise<{
                id: string;
                metadataUri: string;
                timestamp: string;
            }>;
        }>>;
    };
    unpublish: {
        (publisher: string, contractId: string): Promise<Omit<{
            receipt: import("@ethersproject/abstract-provider").TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>;
        prepare: (publisher: string, contractId: string) => Promise<Transaction<Omit<{
            receipt: import("@ethersproject/abstract-provider").TransactionReceipt;
            data: () => Promise<unknown>;
        }, "data">>>;
    };
    private toPublishedContract;
}
//# sourceMappingURL=contract-publisher.d.ts.map