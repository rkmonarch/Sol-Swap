{"version":3,"file":"createSft.cjs","sources":["../../../../../src/plugins/nftModule/operations/createSft.ts"],"sourcesContent":["import {\n  createCreateMetadataAccountV3Instruction,\n  Uses,\n} from '@metaplex-foundation/mpl-token-metadata';\nimport { Keypair, PublicKey } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { assertSft, Sft, SftWithToken } from '../models';\nimport { Option, TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  Creator,\n  CreatorInput,\n  isSigner,\n  makeConfirmOptionsFinalizedOnMainnet,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  SplTokenAmount,\n  toPublicKey,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'CreateSftOperation' as const;\n\n/**\n * Creates a new SFT.\n *\n * ```ts\n * const { sft } = await metaplex\n *   .nfts()\n *   .createSft({\n *     name: 'My SFT',\n *     uri: 'https://example.com/my-sft',\n *     sellerFeeBasisPoints: 250, // 2.5%\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const createSftOperation = useOperation<CreateSftOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type CreateSftOperation = Operation<\n  typeof Key,\n  CreateSftInput,\n  CreateSftOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type CreateSftInput = {\n  /**\n   * The authority that will be able to make changes\n   * to the created SFT.\n   *\n   * This is required as a Signer because creating the\n   * metadata account requires the update authority to be part\n   * of the creators array as a verified creator.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  updateAuthority?: Signer;\n\n  /**\n   * The authority allowed to mint new tokens for the mint account\n   * that is either explicitly provided or about to be created.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  mintAuthority?: Signer;\n\n  /**\n   * The authority allowed to freeze token account associated with the\n   * mint account that is either explicitly provided or about to be created.\n   *\n   * @defaultValue `metaplex.identity().publicKey`\n   */\n  freezeAuthority?: Option<PublicKey>;\n\n  /**\n   * The address of the new mint account as a Signer.\n   * This is useful if you already have a generated Keypair\n   * for the mint account of the SFT to create.\n   *\n   * @defaultValue `Keypair.generate()`\n   */\n  useNewMint?: Signer;\n\n  /**\n   * The address of the existing mint account that should be converted\n   * into an SFT. The account at this address should have the right\n   * requirements to become an SFT, e.g. it shouldn't already have\n   * a metadata account associated with it.\n   *\n   * @defaultValue Defaults to creating a new mint account with the\n   * right requirements.\n   */\n  useExistingMint?: PublicKey;\n\n  /**\n   * The owner of a token account associated with the SFT to create.\n   *\n   * This is completely optional as creating an SFT does not require\n   * the existence of a token account. When provided, an associated\n   * token account will be created from the given owner.\n   *\n   * You may alternatively pass the `tokenAddress` parameter instead.\n   *\n   * @defaultValue Defaults to not creating and/or minting\n   * any token account.\n   */\n  tokenOwner?: PublicKey;\n\n  /**\n   * An explicit token account associated with the SFT to create.\n   *\n   * This is completely optional as creating an SFT does not require\n   * the existence of a token account.\n   *\n   * When provided, the token account will be created if and only\n   * if no account exists at the given address. When that's the case,\n   * the `tokenAddress` must be provided as a Signer as we're creating\n   * and initializing the account at this address.\n   *\n   * You may alternatively pass the `tokenOwner` parameter instead.\n   *\n   * @defaultValue Defaults to not creating and/or minting\n   * any token account.\n   */\n  tokenAddress?: PublicKey | Signer;\n\n  /**\n   * The amount of tokens to mint to the token account initially\n   * if a token account is created.\n   *\n   * This is only relevant if either the `tokenOwner` or `tokenAddress`\n   * is provided.\n   *\n   * @defaultValue Defaults to not minting any tokens.\n   */\n  tokenAmount?: SplTokenAmount;\n\n  /**\n   * The number of decimal points used to define token amounts.\n   *\n   * @defaultValue `0`\n   */\n  decimals?: number;\n\n  /** The URI that points to the JSON metadata of the asset. */\n  uri: string;\n\n  /** The on-chain name of the asset, e.g. \"My SFT\". */\n  name: string;\n\n  /**\n   * The royalties in percent basis point (i.e. 250 is 2.5%) that\n   * should be paid to the creators on each secondary sale.\n   */\n  sellerFeeBasisPoints: number;\n\n  /**\n   * The on-chain symbol of the asset, stored in the Metadata account.\n   * E.g. \"MYSFT\".\n   *\n   * @defaultValue `\"\"`\n   */\n  symbol?: string;\n\n  /**\n   * {@inheritDoc CreatorInput}\n   * @defaultValue\n   * Defaults to using the provided `updateAuthority` as the only verified creator.\n   * ```ts\n   * [{\n   *   address: updateAuthority.publicKey,\n   *   authority: updateAuthority,\n   *   share: 100,\n   * }]\n   * ```\n   */\n  creators?: CreatorInput[];\n\n  /**\n   * Whether or not the SFT's metadata is mutable.\n   * When set to `false` no one can update the Metadata account,\n   * not even the update authority.\n   *\n   * @defaultValue `true`\n   */\n  isMutable?: boolean;\n\n  /**\n   * When this field is not `null`, it indicates that the SFT\n   * can be \"used\" by its owner or any approved \"use authorities\".\n   *\n   * @defaultValue `null`\n   */\n  uses?: Option<Uses>;\n\n  /**\n   * Whether the created SFT is a Collection SFT.\n   * When set to `true`, the SFT will be created as a\n   * Sized Collection SFT with an initial size of 0.\n   *\n   * @defaultValue `false`\n   */\n  isCollection?: boolean;\n\n  /**\n   * The Collection NFT that this new SFT belongs to.\n   * When `null`, the created SFT will not be part of a collection.\n   *\n   * @defaultValue `null`\n   */\n  collection?: Option<PublicKey>;\n\n  /**\n   * The collection authority that should sign the created SFT\n   * to prove that it is part of the provided collection.\n   * When `null`, the provided `collection` will not be verified.\n   *\n   * @defaultValue `null`\n   */\n  collectionAuthority?: Option<Signer>;\n\n  /**\n   * Whether or not the provided `collectionAuthority` is a delegated\n   * collection authority, i.e. it was approved by the update authority\n   * using `metaplex.nfts().approveCollectionAuthority()`.\n   *\n   * @defaultValue `false`\n   */\n  collectionAuthorityIsDelegated?: boolean;\n\n  /**\n   * Whether or not the provided `collection` is a sized collection\n   * and not a legacy collection.\n   *\n   * @defaultValue `true`\n   */\n  collectionIsSized?: boolean;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type CreateSftOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n\n  /** The newly created SFT and, potentially, its associated token. */\n  sft: Sft | SftWithToken;\n\n  /** The address of the mint account. */\n  mintAddress: PublicKey;\n\n  /** The address of the metadata account. */\n  metadataAddress: PublicKey;\n\n  /** The address of the token account if any. */\n  tokenAddress: PublicKey | null;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const createSftOperationHandler: OperationHandler<CreateSftOperation> = {\n  handle: async (\n    operation: CreateSftOperation,\n    metaplex: Metaplex,\n    scope: OperationScope\n  ) => {\n    const {\n      useNewMint = Keypair.generate(),\n      useExistingMint,\n      tokenOwner,\n      tokenAddress: tokenSigner,\n    } = operation.input;\n\n    const mintAddress = useExistingMint ?? useNewMint.publicKey;\n    const associatedTokenAddress = tokenOwner\n      ? metaplex.tokens().pdas().associatedTokenAccount({\n          mint: mintAddress,\n          owner: tokenOwner,\n          programs: scope.programs,\n        })\n      : null;\n    const tokenAddress = tokenSigner\n      ? toPublicKey(tokenSigner)\n      : associatedTokenAddress;\n\n    let tokenExists: boolean;\n    if (!!useExistingMint && !!tokenAddress) {\n      const tokenAccount = await metaplex.rpc().getAccount(tokenAddress);\n      tokenExists = tokenAccount.exists;\n    } else {\n      tokenExists = false;\n    }\n\n    const builder = await createSftBuilder(\n      metaplex,\n      { ...operation.input, useNewMint, tokenExists },\n      scope\n    );\n    scope.throwIfCanceled();\n\n    const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(\n      metaplex,\n      scope.confirmOptions\n    );\n    const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n    scope.throwIfCanceled();\n\n    const sft = await metaplex.nfts().findByMint(\n      {\n        mintAddress: output.mintAddress,\n        tokenAddress: output.tokenAddress ?? undefined,\n      },\n      scope\n    );\n    scope.throwIfCanceled();\n\n    assertSft(sft);\n    return { ...output, sft };\n  },\n};\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type CreateSftBuilderParams = Omit<CreateSftInput, 'confirmOptions'> & {\n  /**\n   * Whether or not the provided token account already exists.\n   * If `false`, we'll add another instruction to create it.\n   *\n   * @defaultValue `true`\n   */\n  tokenExists?: boolean;\n\n  /** A key to distinguish the instruction that creates the mint account. */\n  createMintAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the mint account. */\n  initializeMintInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the associated token account. */\n  createAssociatedTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the token account. */\n  createTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the token account. */\n  initializeTokenInstructionKey?: string;\n\n  /** A key to distinguish the instruction that mints tokens. */\n  mintTokensInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the metadata account. */\n  createMetadataInstructionKey?: string;\n};\n\n/**\n * @group Transaction Builders\n * @category Contexts\n */\nexport type CreateSftBuilderContext = Omit<CreateSftOutput, 'response' | 'sft'>;\n\n/**\n * Creates a new SFT.\n *\n * ```ts\n * const transactionBuilder = await metaplex\n *   .nfts()\n *   .builders()\n *   .createSft({\n *     name: 'My SFT',\n *     uri: 'https://example.com/my-sft',\n *     sellerFeeBasisPoints: 250, // 2.5%\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const createSftBuilder = async (\n  metaplex: Metaplex,\n  params: CreateSftBuilderParams,\n  options: TransactionBuilderOptions = {}\n): Promise<TransactionBuilder<CreateSftBuilderContext>> => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    useNewMint = Keypair.generate(),\n    updateAuthority = metaplex.identity(),\n    mintAuthority = metaplex.identity(),\n  } = params;\n\n  const mintAndTokenBuilder = await createMintAndTokenForSftBuilder(\n    metaplex,\n    params,\n    { programs, payer },\n    useNewMint\n  );\n  const { mintAddress, tokenAddress } = mintAndTokenBuilder.getContext();\n\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n  const metadataPda = metaplex.nfts().pdas().metadata({\n    mint: mintAddress,\n    programs,\n  });\n  const creatorsInput: CreatorInput[] = params.creators ?? [\n    {\n      address: updateAuthority.publicKey,\n      authority: updateAuthority,\n      share: 100,\n    },\n  ];\n  const creators: Option<Creator[]> =\n    creatorsInput.length > 0\n      ? creatorsInput.map((creator) => ({\n          ...creator,\n          verified: creator.address.equals(updateAuthority.publicKey),\n        }))\n      : null;\n\n  const createMetadataInstruction = createCreateMetadataAccountV3Instruction(\n    {\n      metadata: metadataPda,\n      mint: mintAddress,\n      mintAuthority: mintAuthority.publicKey,\n      payer: payer.publicKey,\n      updateAuthority: updateAuthority.publicKey,\n    },\n    {\n      createMetadataAccountArgsV3: {\n        data: {\n          name: params.name,\n          symbol: params.symbol ?? '',\n          uri: params.uri,\n          sellerFeeBasisPoints: params.sellerFeeBasisPoints,\n          creators,\n          collection: params.collection\n            ? { key: params.collection, verified: false }\n            : null,\n          uses: params.uses ?? null,\n        },\n        isMutable: params.isMutable ?? true,\n        collectionDetails: params.isCollection\n          ? { __kind: 'V1', size: 0 } // Program will hardcode size to zero anyway.\n          : null,\n      },\n    },\n    tokenMetadataProgram.address\n  );\n\n  // When the payer is different than the update authority, the latter will\n  // not be marked as a signer and therefore signing as a creator will fail.\n  createMetadataInstruction.keys[4].isSigner = true;\n\n  const verifyAdditionalCreatorInstructions = creatorsInput\n    .filter((creator) => {\n      return (\n        !!creator.authority &&\n        !creator.address.equals(updateAuthority.publicKey)\n      );\n    })\n    .map((creator) => {\n      return metaplex.nfts().builders().verifyCreator(\n        {\n          mintAddress,\n          creator: creator.authority,\n        },\n        { programs, payer }\n      );\n    });\n\n  return (\n    TransactionBuilder.make<CreateSftBuilderContext>()\n      .setFeePayer(payer)\n      .setContext({\n        mintAddress,\n        metadataAddress: metadataPda,\n        tokenAddress,\n      })\n\n      // Create the mint and token accounts before minting 1 token to the owner.\n      .add(mintAndTokenBuilder)\n\n      // Create metadata account.\n      .add({\n        instruction: createMetadataInstruction,\n        signers: [payer, mintAuthority, updateAuthority],\n        key: params.createMetadataInstructionKey ?? 'createMetadata',\n      })\n\n      // Verify additional creators.\n      .add(...verifyAdditionalCreatorInstructions)\n\n      // Verify collection.\n      .when(!!params.collection && !!params.collectionAuthority, (builder) =>\n        builder.add(\n          metaplex\n            .nfts()\n            .builders()\n            .verifyCollection(\n              {\n                mintAddress,\n                collectionMintAddress: params.collection as PublicKey,\n                collectionAuthority: params.collectionAuthority as Signer,\n                isDelegated: params.collectionAuthorityIsDelegated ?? false,\n                isSizedCollection: params.collectionIsSized ?? true,\n              },\n              { payer, programs }\n            )\n        )\n      )\n  );\n};\n\nconst createMintAndTokenForSftBuilder = async (\n  metaplex: Metaplex,\n  params: CreateSftBuilderParams,\n  options: TransactionBuilderOptions,\n  useNewMint: Signer\n): Promise<\n  TransactionBuilder<{ mintAddress: PublicKey; tokenAddress: PublicKey | null }>\n> => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    mintAuthority = metaplex.identity(),\n    freezeAuthority = metaplex.identity().publicKey,\n    tokenExists = false,\n  } = params;\n\n  const mintAddress = params.useExistingMint ?? useNewMint.publicKey;\n  const associatedTokenAddress = params.tokenOwner\n    ? metaplex.tokens().pdas().associatedTokenAccount({\n        mint: mintAddress,\n        owner: params.tokenOwner,\n        programs,\n      })\n    : null;\n  const tokenAddress = params.tokenAddress\n    ? toPublicKey(params.tokenAddress)\n    : associatedTokenAddress;\n\n  const builder = TransactionBuilder.make<{\n    mintAddress: PublicKey;\n    tokenAddress: PublicKey | null;\n  }>()\n    .setFeePayer(payer)\n    .setContext({\n      mintAddress,\n      tokenAddress,\n    });\n\n  // Create the mint account if it doesn't exist.\n  if (!params.useExistingMint) {\n    builder.add(\n      await metaplex\n        .tokens()\n        .builders()\n        .createMint(\n          {\n            decimals: params.decimals ?? 0,\n            mint: useNewMint,\n            mintAuthority: mintAuthority.publicKey,\n            freezeAuthority,\n            createAccountInstructionKey: params.createMintAccountInstructionKey,\n            initializeMintInstructionKey: params.initializeMintInstructionKey,\n          },\n          { programs, payer }\n        )\n    );\n  }\n\n  // Create the token account if it doesn't exist.\n  const isNewToken = !!params.tokenAddress && isSigner(params.tokenAddress);\n  const isNewAssociatedToken = !!params.tokenOwner;\n  if (!tokenExists && (isNewToken || isNewAssociatedToken)) {\n    builder.add(\n      await metaplex\n        .tokens()\n        .builders()\n        .createToken(\n          {\n            mint: mintAddress,\n            owner: params.tokenOwner,\n            token: params.tokenAddress as Signer | undefined,\n            createAssociatedTokenAccountInstructionKey:\n              params.createAssociatedTokenAccountInstructionKey,\n            createAccountInstructionKey:\n              params.createTokenAccountInstructionKey,\n            initializeTokenInstructionKey: params.initializeTokenInstructionKey,\n          },\n          { programs, payer }\n        )\n    );\n  }\n\n  // Mint provided amount to the token account.\n  if (tokenAddress && params.tokenAmount) {\n    builder.add(\n      await metaplex.tokens().builders().mint(\n        {\n          mintAddress,\n          toToken: tokenAddress,\n          toTokenExists: true,\n          amount: params.tokenAmount,\n          mintAuthority,\n          mintTokensInstructionKey: params.mintTokensInstructionKey,\n        },\n        { programs, payer }\n      )\n    );\n  }\n\n  return builder;\n};\n"],"names":["Key","createSftOperation","useOperation","createSftOperationHandler","handle","operation","metaplex","scope","useNewMint","Keypair","generate","useExistingMint","tokenOwner","tokenAddress","tokenSigner","input","mintAddress","publicKey","associatedTokenAddress","tokens","pdas","associatedTokenAccount","mint","owner","programs","toPublicKey","tokenExists","tokenAccount","rpc","getAccount","exists","builder","createSftBuilder","throwIfCanceled","confirmOptions","makeConfirmOptionsFinalizedOnMainnet","output","sendAndConfirm","sft","nfts","findByMint","undefined","assertSft","params","options","payer","getDefaultFeePayer","updateAuthority","identity","mintAuthority","mintAndTokenBuilder","createMintAndTokenForSftBuilder","getContext","tokenMetadataProgram","getTokenMetadata","metadataPda","metadata","creatorsInput","creators","address","authority","share","length","map","creator","verified","equals","createMetadataInstruction","createCreateMetadataAccountV3Instruction","createMetadataAccountArgsV3","data","name","symbol","uri","sellerFeeBasisPoints","collection","key","uses","isMutable","collectionDetails","isCollection","__kind","size","keys","isSigner","verifyAdditionalCreatorInstructions","filter","builders","verifyCreator","TransactionBuilder","make","setFeePayer","setContext","metadataAddress","add","instruction","signers","createMetadataInstructionKey","when","collectionAuthority","verifyCollection","collectionMintAddress","isDelegated","collectionAuthorityIsDelegated","isSizedCollection","collectionIsSized","freezeAuthority","createMint","decimals","createAccountInstructionKey","createMintAccountInstructionKey","initializeMintInstructionKey","isNewToken","isNewAssociatedToken","createToken","token","createAssociatedTokenAccountInstructionKey","createTokenAccountInstructionKey","initializeTokenInstructionKey","tokenAmount","toToken","toTokenExists","amount","mintTokensInstructionKey"],"mappings":"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"}